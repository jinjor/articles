---
title: PNG を読んでみた
emoji: "🖼️"
type: "tech"
topics: ["png"]
publication_name: knowledgework
published: false
---

※ 全体的に WIP

こんにちは。ナレッジワークの [torii](https://twitter.com/jinjor) です。
社内イベント（ LT 大会）で発表した内容をブログでも軽く紹介したいと思います！

# 経緯（社内勉強会の取り組みについて）

ナレッジワークでは以前より Encraft という社外向けの勉強会を定期的に開催していますが、社内向けにも Encraft Share Day という勉強会があります。
Encraft Share Day は、より多くのメンバーに発表の場を提供することで技術発信の経験を積んでもらう目的で開催されています。

そして今回は発表者の１人として私 torii に白羽の矢が立ったので必死でネタを考えた結果、「PNG の仕様を勉強して発表しよう」という「勉強会駆動勉強」をすることになりました。
普段の業務ではライブラリを使って処理する PNG 画像ですが、「中身を深く知ることでより画像ファイルを上手く扱えるのではないか」というのがこのテーマを選んだ狙いです！

# 発表内容

前置きが長くなりましたが、ここからは簡単に発表した内容をこの記事でも説明します。
タイトルは「PNG を読んでみた」、つまり PNG 画像のバイナリを自前でパースしてみたということになります。

この発表では技術的な内容もざっと解説していますが、どちらかというと内容を読んでみることで得た知識や考察に力点をおいています。
具体的なパースの仕方などについては触れていないため詳細は他の記事をあたっていただければと思います。

TODO: SpeakerDeck
（実際の発表では口頭で説明をしているのでスライドだけでは説明が不足している点にご留意ください）

## お題

iPhone で撮影したハンバーガーの写真です。

## PNG フォーマットの構造

PNG バイナリは、先頭に PNG であることを示す８バイトの識別子があり、その後はチャンクと呼ばれるデータのまとまりが最後まで連なる構造になっています。
各チャンクは、長さ・種別・データ・CRC という共通の構造から成り、チャンクの種別によってデータの内容が変わります。

<img alt="PNG フォーマットの構造" src="../images/read-png-file/structure.png" width="400px">
<img alt="チャンク共通の構造" src="../images/read-png-file/chunk.png" width="400px">

![PNG フォーマットの構造](/images/read-png-file/structure.png =400x)
![チャンク共通の構造](/images/read-png-file/chunk.png =400x)

チャンクの中でまず重要なのが IHDR （画像ヘッダ）と呼ばれるチャンクです。
IHDR チャンクは設置が必須であり、画像のサイズやカラータイプ、インターレースの有無といった主要な情報が格納されています。
カラータイプが 3 (インデックス画像)の場合は PLTE チャンクの設置も必須になっています。

補助チャンクと呼ばれる設置が任意のチャンクもあります。
種別はたくさんあるのですが、一例を挙げると tEXt チャンクは Key-Value の形式で画像のタイトルや更新日時といったメタデータを埋め込めるようになっています。

次にメインとなる IDAT チャンクです。ここに画像の本体となるピクセルデータが格納されています（説明は後述）

そして最後に、データの終端を示す IEND チャンクがあります。

## ヘッダ・メタデータを読んでみた

ここまでの情報で、ヘッダ・メタデータが読めるようになったので早速読んでみました。

以下では、実際に画像データに入っていたメタデータ（補助チャンク）を紹介します。

### iCCP

iCCP チャンクに格納されている情報は ICC プロファイルと呼ばれ、異なるデバイス間で色を正確に再現するために利用されます。
（仕様が）

### eXIf

eXIf チャンクは、カメラの種類や撮影場所、撮影日時などを記録しておくための領域です。
Exif は JPEG でも使われている仕様で、読み方は別途そちらのドキュメントを参照する必要があります。

お題の画像を解析した結果、かなり色々な情報が詰め込まれていることがわかりました。火曜のお昼にオフィスの近くでハンバーガーを食べていたのが丸わかりです（笑）
多くの Web サービスではプライバシーを考慮して、画像アップロード時にこのチャンクを削除するなどの対策をしているようです。

### iTXt

iTXt チャンクは、 tEXt チャンクの国際化（international）版です。
本来は tEXt チャンク同様に Key-Value 形式で保存するものですが、ここでは Adobe XMP という形式の XML が入っており、 eXIf とも重複するメタデータが一式入っていました。

## IDAT チャンクの構造

IDAT チャンクには zlib 圧縮された画像データが入っています。
ただし、この zlib 圧縮されている画像データは圧縮効率を高めるために事前にフィルタ処理を加えたものになります。
したがって、元の画像を取り出すには、解凍したデータに逆のフィルタをかけて復元する必要があります。

| type | 名前    | 説明                                                                           |
| :--- | :------ | :----------------------------------------------------------------------------- |
| 0    | None    | フィルタなし                                                                   |
| 1    | Sub     | 左隣のピクセル値との差分                                                       |
| 2    | Top     | 上隣のピクセル値との差分                                                       |
| 3    | Average | 左隣と上隣のピクセル値の平均との差分                                           |
| 4    | Peath   | Peath アルゴリズムによって左・上・左上の中から選択されたのピクセルの値との差分 |

TODO: 画像
（補足：値はバイトの範囲に収まるように 256 の剰余を計算します）

逆にフィルタ処理された画像を元に戻すには、左から順番に加算していきます。

## 画像を自前でパースして描画してみた様子

左上の画像が `<img>` 要素で普通に描画した見本画像で、右が自前でパースしたものを `<canvas>` 要素に 1px ずつ描画したものです。
見ての通り、同じ画像が描画できています。
しかし、初期バージョンでは画像の「フェッチ -> パース -> 描画」を全て直列で実行していたため、描画されるまでに空白の状態で待たなければなりませんでした。
そこで、ストリーミングで処理できるバージョンを実装し、「フェッチ -> パース -> 描画」を全て並行してできるようにした結果、読み込んだ部分から（上から）順に描画されていき、体験を改善させることができました。

ここまでで、お題の画像を無事読み込めたことで仕様を正しく理解できたことが確認できました。
ここからは、実装の過程で気になったことを検証していきます。

## 検証１：インターレースで体験がよくなるか

PNG 画像はインターレース方式でエンコードすることもできます。
インターレース方式では、ピクセルの順番を並び替えて転送することで、低解像度ではあるが全体が認識できる画像を優先的に表示することができます。

PNG のインターレースでは Adam7 というアルゴリズムが使われます。
ピクセル全体を 8x8 の領域に分割し、以下のように 1〜7 の番号を振ります。

TODO: 画像のほうがいいかも

|     |     |     |     |     |     |     |     |
| :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- |
| 1   | 6   | 4   | 6   | 2   | 6   | 4   | 6   |
| 7   | 7   | 7   | 7   | 7   | 7   | 7   | 7   |
| 5   | 6   | 5   | 6   | 5   | 6   | 5   | 6   |
| 7   | 7   | 7   | 7   | 7   | 7   | 7   | 7   |
| 3   | 6   | 4   | 6   | 3   | 6   | 4   | 6   |
| 7   | 7   | 7   | 7   | 7   | 7   | 7   | 7   |
| 5   | 6   | 5   | 6   | 5   | 6   | 5   | 6   |
| 7   | 7   | 7   | 7   | 7   | 7   | 7   | 7   |

そして、１のみを集めて作った画像、2 のみを集めて作った画像、...、の順番に画像を並べます。
こうすることで、読み込み時に低解像度の画像をまず描画し、徐々に解像度を上げながら表示することが可能になります。
（そのままだとピクセルが飛び飛びなので、まだ読み込まれていない部分は読み込み済みのピクセルで補完する必要があります）

先ほどの画像をインターレースありの画像に変換して読み込むと次のようになりました。
読み込みを開始してすぐに粗い画像が表示されることがわかります。（画像のサイズにもよりますが、今回の画像では粗さは気になりませんでした。）

## 検証２：フィルタの効果

「事前にフィルタ処理をかけることで本当に圧縮率が高まっているのか」も気になったので、調べてみました。
検証方法としては、元の画像を復元した後、再び type 1 から 4 のフィルタをかけて圧縮し直してサイズを比較しています（全行で同じフィルタをかけています）

TODO: 画像

結果は図の通り、ほぼ全ての画像で何らかのフィルタをかけた方が圧縮後のサイズが小さくなるということがわかりました。
唯一、コンソール画面のスクリーンショットだけはフィルタをかけた方が逆に圧縮後のサイズが大きくなってしまいました。
原因は追っていませんが、ほとんどが黒のベタ塗りという画像の特性によるものと推察されます。この辺は深ぼっていくと面白そうですね。

## 検証３：サービスはユーザーがアップロードした画像をどう扱うか

上の方で述べた通り、 eXIf チャンクや iTXt チャンクにはユーザーのプライバシーに関わる情報が多数格納されていました。
そこで、著名なサービスをいくつかピックアップしてアップロードした画像のメタデータがどのように変わっているかを調べてみました。

TODO: 画像

今回調査した全てサービスで、プライバシーに関わるようなデータは削除されていることがわかりました。
弊社サービスでも削除されていることが確認できたので安心しました。

# ふりかえり

PNG というテーマを決めた時はほとんど知識のない状態だったので、発表するに値する内容になるかヒヤヒヤしていましたが、蓋を開けたら制限時間の 10 分を軽くオーバーする内容になって（ごめんなさい）よかったです。社内からも面白かった・わかりやすかったという声が多数あって嬉しいです！

次は他の画像ファイルや動画ファイル、PDF なども読んでみたいですね（でもコミットはしません！笑）
